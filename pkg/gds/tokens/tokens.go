// Package tokens handles the creation and verification of JWT tokens for authentication.
package tokens

import (
	"crypto/rsa"
	"fmt"
	"io/ioutil"

	jwt "github.com/golang-jwt/jwt/v4"
	"github.com/segmentio/ksuid"
)

// TokenManager handles the creation and verification of RSA signed JWT tokens. To
// facilitate signing key rollover, TokenManager can accept multiple keys identified by
// a ksuid. JWT tokens generated by token managers include a kid in the header that
// allows the token manager to verify the key with the specified signature. To sign keys
// the token manager will always use the latest private key by ksuid.
type TokenManager struct {
	currentKeyID ksuid.KSUID
	currentKey   *rsa.PrivateKey
	keys         map[ksuid.KSUID]*rsa.PublicKey
}

// Claims implements custom claims for the GDS application to hold user data provided
// from external openid sources. It also embeds the standard JWT claims.
type Claims struct {
	jwt.StandardClaims
	Domain  string `json:"hd"`
	Email   string `json:"email"`
	Name    string `json:"name"`
	Picture string `json:"picture"`
}

// New creates a TokenManager with the specified keys which should be a mapping of KSUID
// strings to paths to files that contain PEM encoded RSA private keys. This input is
// specifically designed for the config environment variable so that keys can be loaded
// from k8s or vault secrets that are mounted as files on disk.
func New(keys map[string]string) (tm *TokenManager, err error) {
	tm = &TokenManager{
		keys: make(map[ksuid.KSUID]*rsa.PublicKey),
	}

	for kid, path := range keys {
		// Parse the key id
		var keyID ksuid.KSUID
		if keyID, err = ksuid.Parse(kid); err != nil {
			return nil, fmt.Errorf("could not parse kid %q for path %s: %s", kid, path, err)
		}

		// Load the keys from disk
		var data []byte
		if data, err = ioutil.ReadFile(path); err != nil {
			return nil, fmt.Errorf("could not read kid %s from %s: %s", kid, path, err)
		}

		var key *rsa.PrivateKey
		if key, err = jwt.ParseRSAPrivateKeyFromPEM(data); err != nil {
			return nil, fmt.Errorf("could not parse RSA private key kid %s from %s: %s", kid, path, err)
		}

		// Add the key to the key map
		tm.keys[keyID] = &key.PublicKey

		// Set the current key if it is the latest key
		if tm.currentKey == nil || keyID.Time().After(tm.currentKeyID.Time()) {
			tm.currentKey = key
			tm.currentKeyID = keyID
		}
	}

	return tm, nil
}

// Keys returns the map of ksuid to public key for use externally.
func (tm *TokenManager) Keys() map[ksuid.KSUID]*rsa.PublicKey {
	return tm.keys
}

// CurrentKey returns the ksuid of the current key being used to sign tokens.
func (tm *TokenManager) CurrentKey() ksuid.KSUID {
	return tm.currentKeyID
}
